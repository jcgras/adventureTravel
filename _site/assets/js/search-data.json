{
  
  "0": {
    "title": "Project structure",
    "content": "Project Structure . . Application modules Static images | | Redux, one state to rule them all Actions | Reducers | Store | | Components Connecting the components to the store | | Screens/Pages | . Application modules . A structure must be simple enough for new team members to quickly get on board and immerse themselves into the project. . React’s ecosystem offers users complete control over everything, without being tied to any particular way of doing things. However, whenever we work on a React project it is necessary to use some kind of consensus to organize the source code. With this in mind, we believe that the ideal React project structure is the one that allows you to move around your code with the least amount of effort. Following this principle, Adventure Travel is made up of a simple project structure that allows you to easily scalate, adapt, reuse and create React Native components. In any case, you are welcome to adjust this structure for your own use case. . To get into context, let’s start analyzing the project from the JavaScript source code located in the /src folder. Remember that React Native uses the JavaScript language to generate from the source code to iOS and Android platforms, both in the /ios and android folders respectively. Inside the /src folder all the modules of the application will be organized. . . Folder Description . common | It contains the common elements such as global styles, colors, utils, etc. | . components | Here we place the application components and their related styles. | . images | It contains the static images used in the project such as illustrations, logos, etc. | . navigation | navigation | . redux | redux | . screens | It contains the components relating to the application screens and their related styles. | . You have probably noticed that in each of these folders the files index.js and package.json are included. Both files are used to export and define the module with global access within the project. . . In the index.js file we must include all the module reference (imports) and then export it to make it visible outside the folder. . /src/common/index.js . import Styles from &quot;./Styles&quot;; import Color from &quot;./Color&quot;; import Device from &quot;./Device&quot;; import Images from &quot;./Images&quot;; import Coordinates from &quot;./Coordinates&quot;; import Util from &quot;./Util&quot;; export { Styles, Color, Device, Images, Coordinates, Util } . Also using the package.json file we can define the name of the package as global and use it anywhere in the project. . /src/common/package.json . { &quot;name&quot;: &quot;@common&quot; } . Now if you need to import something (like Color) from the common module you can refered it using @common route instead of all the static route. . import { Color } from &quot;@common&quot;; const primaryColor = Color.primary; . Static images . In any mobile application project it is necessary to use static image files (embedded in the app) instead of always downloading them from the Internet. This applies mainly for image files such as illustrations, logos, icons, etc. For this reason we have included a single folder to store all the embedded image files, located in the path: /src/images. We have included also the Images.js file in the @common module to export the reference of all the static images, located in the images folder. . . /src/common/Images.js . export default { logoWhite: require(&quot;@images/logos/logoWhite.png&quot;), IllustSettings: require(&quot;@images/illustrations/settings.png&quot;), } . Whenever you need to use a static image just reference Images from the @common module. . import { Images } from &quot;@common&quot;; render() { return ( &lt;View&gt; &lt;Image source={Images.logoWhite} /&gt; &lt;/View&gt; ); } . . Redux, one state to rule them all . Redux handles the entire application data flow within a single container while the previous state persists as well. . As an important part of our architecture, we include Redux for application status management. With Redux we can have one application state as a global state (“Single source of truth”), that includes all application data -like bookings and bookmarks- but also temporary states like search results, search history or popular destinations. . Tree view from React Native Debugger . To use this library (actually Redux is a library) a redux module was created that includes the actions and reducers folders and the store.js file. Following the same logic as above, we have also included the package.json file for the module name. . . Actions . The whole state of the app is stored in an object tree inside a single store. The only way to change the state tree is to emit an action, an object describing what happened. (Redux Documentation) . Following this principle, the actions folder has been created as a container for the action files of each data object. For example, we have included the bookmarks.js file for all actions that manage bookmarks objects (saved items). Inside this file we can find a set of functions (Action Creators) to manage each action, for example, adding a new bookmark. So actions are the information (Objects) and action creator are functions that return these actions. . /src/redux/actions/bookmarks.js . const addBookmark = bookmark =&gt; { return { type: &quot;ADD_BOOKMARK&quot;, payload: bookmark } } // ....... export { // ....... addBookmark }; . Reducers . Actions only tell what to do, but they don’t tell how to do, so reducers are the pure functions that take the current state and action and return the new state and tell the store how to do. To summarize, the reducers specify how the actions transform the state tree. We have included the reducers folder to group the reducers of each object. . /src/redux/reducers/bookmarks.js . const defaultState = []; function reducer(state = defaultState, { type, payload }) { switch (type) { case &quot;SET_BOOKMARKS&quot;: { return payload; } case &quot;ADD_BOOKMARK&quot;: { return [...state, payload]; } case &quot;DELETE_BOOKMARK&quot;: { return state.filter(b =&gt; b.id !== payload); } case &quot;CLEAR_BOOKMARKS&quot;: { return defaultState; } default: return state; } } export default reducer; . Store . Basically the store is the object which holds the state of the application. We have created the store.js file to include the single store for the entire application, as recommended by the Redux documentation: . It’s important to note that you’ll only have a single store in a Redux application. When you want to split your data handling logic, you’ll use reducer composition instead of many stores. - Redux Documentation . To start using the store instance you just need to import and call createStore. . import { createStore } from &#39;redux&#39; import todoApp from &#39;./reducers&#39; const store = createStore(todoApp) . But in our case we use multiple reducers and it is necessary to include the combineReducers() function to combine several reducers into one. . /src/redux/store.js . import { createStore, combineReducers } from &quot;redux&quot;; // ... import searchHistory from &quot;./reducers/searchHistory&quot;; import bookmarks from &quot;./reducers/bookmarks&quot;; import bookings from &quot;./reducers/bookings&quot;; const reducer = combineReducers({ // ... searchHistory, bookmarks, bookings }); . We also use Redux-Persist to save the Redux store when the app is closed and Redux-Thunk middleware to write Action Creators that return a function instead of an action. This last element is the one that allows us to create actions such as addBookmark as functions. . /src/redux/store.js . const persistConfig = { key: &quot;root&quot;, storage: AsyncStorage, whitelist: [&quot;user&quot;, &quot;explore&quot;, &quot;categories&quot;, &quot;popular&quot;, &quot;searchHistory&quot;, &quot;bookmarks&quot;, &quot;bookings&quot;, &quot;config&quot;], blacklist: [] }; const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose; const persistedReducer = persistReducer(persistConfig, reducer); const store = createStore(persistedReducer, composeEnhancers(applyMiddleware(thunk))); let persistor = persistStore(store); export { persistor, store }; . How the store is connected to the UI is specified below. . . Components . As you probably know, React bases its architecture on components. That is: each piece of an app is handled as an isolated component (class or Hooks) where its own states, properties, styles and the access to the store are handled. With Adventure Travel you have a variety ready-to-use components to create your own mobile application. Components like ButtonGradient, CardPopular or ImageCollage can be found in the /src/components folder. Similarly we have created a folder to organize the components relating to the screens of the app: /src/screens. In this way we separate more atomic components like ButtonGradient from the more complex ones that compose a screen. . Basically each component extends from React.PureComponent and implements a render() method where the UI is returned in jsx format. . /src/components/ButtonBookmark/index.js . import React from &quot;react&quot;; import PropTypes from &quot;prop-types&quot;; class ButtonBookmark extends React.PureComponent { constructor(props) { super(props); } render() { // ... } } ButtonBookmark.propTypes = { experienceId: PropTypes.number } const styles = StyleSheet.create({ content: { alignSelf: &quot;flex-end&quot;, alignItems: &quot;flex-end&quot;, padding: 8 }, icon: { fontSize: 20 } }); . In each component we also include the use of propTypes to declare the properties required by the component and its data type. When props are passed to a component, they are checked against the type definitions configured in the propTypes property. When an invalid value is passed for a prop, a warning is displayed on the console. To learn more about how you can use prop-types and all the available validators, see their documentation. . Likewise, each component includes the reference to the component’s own styles using StyleSheet within the same file. Using the constant styles you can access the styles inside each component. . Connecting the components to the store . To connect the Redux store to the UI (components) we use the connect() function from react-redux. This function provides to the connected component the data it requires from the store, and the functions it can use to send actions to the store. If the component requires the use of an action that handles the state of the application, such as addBookmark, we can import the functions that we had already created in the actions folder. . import React from &quot;react&quot;; import { addBookmark, deleteBookmark } from &quot;@redux/actions/bookmarks&quot;; import { connect } from &quot;react-redux&quot;; . Then we must create the mapStateToProps object to specify the properties we want to use from the global state and the mapDispatchToProps object to link the imported functions that act on the global state. We can then invoke the connect function using these objects as parameters and connect the component (ButtonBookmark in this example) to export it. This way you can access the declared properties to read the global state values and the functions to modify the global state. . /src/components/ButtonBookmark/index.js . import React from &quot;react&quot;; import PropTypes from &quot;prop-types&quot;; import { addBookmark, deleteBookmark } from &quot;@redux/actions/bookmarks&quot;; import { connect } from &quot;react-redux&quot;; class ButtonBookmark extends React.PureComponent { // ... } // ... const mapStateToProps = state =&gt; { return { bookmarks: state.bookmarks, experiences: state.explore.experienceResults.experiences }; }; const mapDispatchToProps = { addBookmark, deleteBookmark }; export default connect(mapStateToProps, mapDispatchToProps)(ButtonBookmark); . Now within the functions of the component it is possible to access as a property to the global state of bookmarks (this.props.bookmarks) or experiences (this.props.experiences). Similarly, the functions this.props.addBookmark and this.props.deleteBookmark can be accessed as properties. . render() { const booked = this.props.bookmarks.some(b =&gt; b.id == this.props.experienceId); return ( &lt;TouchableOpacity style={styles.content} onPress={booked ? this.removeBookmark : this.addBookmark} &gt; &lt;Icon name={booked ? &quot;heart&quot; : &quot;hearto&quot;} color={booked ? Color.heart : Color.background} style={styles.icon} /&gt; &lt;/TouchableOpacity&gt; ); } addBookmark = () =&gt; { const experience = this.props.experiences.find(e =&gt; e.id == this.props.experienceId); this.props.addBookmark(experience); } removeBookmark = () =&gt; { this.props.deleteBookmark(this.props.experienceId) } . . Screens/Pages . Use FlatList. . react-navigation — Application navigation Navigation structure .",
    "url": "http://localhost:4000/docs/project-structure/",
    "relUrl": "/docs/project-structure/"
  }
  ,"1": {
    "title": "Backend configuration",
    "content": "Backend Configuration . . Backend configuration | . Backend configuration . Firebase configuration. .",
    "url": "http://localhost:4000/docs/backend-config/",
    "relUrl": "/docs/backend-config/"
  }
  ,"2": {
    "title": "App configuration",
    "content": "App configuration . . Enviroment variables | Script commands | Ensuring code quality Formatting the code | | . Enviroment variables . If you need to use enviroment variables like URLs, API keys, usernames, passwords or any other parameter in your app, we include in the project the .env file to store it. We use the react-native-dotenv package to import the configuration variables from a .env file. If you need to use the Google Map Service, for example, you must to include the GOOGLE_MAPS_API_KEY variable with the API key value. You can see how to get a Google Maps API key from this link. . /.env . GOOGLE_MAPS_API_KEY=YourApiKeyValueHere ANOTHER_CONFIG=true . You can then import and use any of the defined variables. . import {GOOGLE_MAPS_API_KEY, ANOTHER_CONFIG} from &#39;react-native-dotenv&#39;; . If you have a separate development and production environment, that requires different configuration variables, you can use an .env file for the development/test environment variables and another .env.production file for the production environment variables. . . Script commands . In addition to the default commands, included in the global package.json file, we have added a few additional yarn commands to provide a quick access to useful tools for code maintenance. You can use, for example, the command yarn clean to delete the node_modules, auto-generated files and reinstall the node_modules again. This command can be useful when you have building errors or incompatibility between new installed modules. As we always say: feel free to add or change what you need, in this case any command. . /package.json . // ....... &quot;scripts&quot;: { &quot;android&quot;: &quot;react-native run-android&quot;, &quot;ios&quot;: &quot;react-native run-ios&quot;, &quot;start&quot;: &quot;react-native start&quot;, &quot;test&quot;: &quot;jest&quot;, &quot;lint&quot;: &quot;eslint .&quot;, &quot;lint:fix&quot;: &quot;eslint --fix .&quot;, &quot;clean&quot;: &quot; rm -fr ./node_modules dist/* ios/build ios/Pods ios/KScoreApp.xcarchive android/build android/app/build public/js public/assets &amp;&amp; yarn&quot; }, // ....... . . Ensuring code quality . As you may have noticed, in the previous scripts, we have also included the lint command to run the ESLint tool. With this tool we can keep our code according to the ECMAScript standard and other rules you want to use to detect and avoid possible errors and inconsistencies. . ESLint is a tool for identifying and reporting on patterns found in ECMAScript/JavaScript code, with the goal of making code more consistent and avoiding bugs. - ESLint Documentation . To configure ESLint you can open the .eslintrc file from the main path. In this file you can include the rules for code validation, however in our case we will extends the rules from react-native-community, the official package for react-native. If you want to extend from another configuration or include your own rules, you can consult the official ESLint documentation. . /.eslintrc . { &quot;extends&quot;: &quot;@react-native-community&quot; } . Then, if you execute the command yarn lint from console a report is generated with the warnings and errors found in the whole project. . . You can also use the command yarn lint:fix to try to fix as many issues as possible. The fixes are made to the actual files themselves and only the remaining unfixed issues are output. You should keep in mind that not all problems can be fixed using this option. . Formatting the code . One way to maintain a common style of code in the project is by using a code formatting tool. In this project we have used Prettier, which is also integrated with ESLint. Prettier supports JavaScript but also other formats like JSX or JSON. . To include Prettier integrated with ESLint we have added plugin:prettier/recommended to ESLint configuration file .eslintrc. . /.eslintrc . { &quot;extends&quot;: [&quot;@react-native-community&quot;, &quot;plugin:prettier/recommended&quot;] } . Now by extending from plugin:prettier/recommended we can also get the unformatted errors using the same yarn lint command. . . This time, with the use of the yarn lint:fix command, the code will take the proper format, keeping the standard in all the source code. .",
    "url": "http://localhost:4000/docs/app-config/",
    "relUrl": "/docs/app-config/"
  }
  ,"3": {
    "title": "Home",
    "content": "Adventure Travel - React Native Template . Version: 1.0.1 . With Adventure Travel template we want to offert more than a set of components and styles. We have carefully created a project where we aim to provide a simple structure for any kind of React Native project, allowing you to adapt, reuse and create react native components easily. . For this project we have been inspired by a travel agency, however, we intend that this template can also be used in a wide range of businesses. If you had a web page for your business, Adventure Travel supports you to convert/extend your current websites to mobile app efficiently. . What do we support in general? . Support for iOS and Android | React Native with JSX | Redux | Backend integration with Firebase | Realtime Database (Store and sync remote data) | Push Notifications | Maps and Geolocation | Google APIs integration | Social logins via facebook or Google | Flexible variable uses via config file | . . Reference links . Try a demo App, avalilable download on Appstore and Google Play: . Purchase or more info Adventure Travel . Documentation | https://docs.svalbard.dev | . iOS demo | https://itunes.apple.com/in/app/adventureTravel/id999999999 | . Android demo | https://play.google.com/store/apps/details?id=com.svalvard.adventureTravel | . . Quick start . Install for iOS / install for Android . Also we include: . Easy customization for your brand | Firebase Synchronize | Instant Search | Support filter by category, tab and pricing | Search history and clean up | Bookmarks and sync across devices | User Profile | Walkthrough animation | Header animation | Easy to change colors and styles | Support to build app via Expo or react-native-cli | Regular feature update and free bug fix | .",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  }
  
}